# 쿠버네티스

> 쿠버네티스(Kubernetes)는 오픈 소스 기반의 컨테이너화된 애플리케이션의 자동 디플로이, 스케일링 등을 제공하는 관리시스템이다.
> 구글에 의해 설계되었으나 현재는 리눅스 재단에 의해 관리되고 있다.
> 여러 클러스터의 호스트 간에 애플리케이션 컨테이너의 배치, 스케일링, 운영을 자동화하기 위한 플랫폼을 제공하기 위해 설계되었다.
> 도커를 포함한 일련의 컨테이너 도구들과 함께 동작한다.



* 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성 있고, 확장가능한 오픈소스 플랫폼

  

  ### 컨테이너

  * VM과 유사하나 격리 속성 완화, 애플리케이션 간 운영체제 공유

  * 자체 파일 시스템, CPU, 메모리, 프로세스 공간 존재

  * 기본 인프라와의 종속성을 끊음. 클라우드나 OS 배포본에 모두 이식 가능

    

    * 기민한 애플리케이션 생성과 배포: VM 이미지를 사용하는 것에 비해 컨테이너 이미지 생성이 보다 쉽고 효율적임.

    * 지속적인 개발, 통합 및 배포: 안정적이고 주기적으로 컨테이너 이미지를 빌드해서 배포할 수 있고 (이미지의 불변성 덕에) 빠르고 쉽게 롤백할 수 있다.

    * 개발과 운영의 관심사 분리: 배포 시점이 아닌 빌드/릴리스 시점에 애플리케이션 컨테이너 이미지를 만들기 때문에, 애플리케이션이 인프라스트럭처에서 디커플된다.

    * 가시성은 OS 수준의 정보와 메트릭에 머무르지 않고, 애플리케이션의 헬스와 그 밖의 시그널을 볼 수 있다.

    * 개발, 테스팅 및 운영 환경에 걸친 일관성: 랩탑에서도 클라우드에서와 동일하게 구동된다.

    * 클라우드 및 OS 배포판 간 이식성: Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine 및 다른 어디에서든 구동된다.

    * 애플리케이션 중심 관리: 가상 하드웨어의 OS에서 애플리케이션을 구동하는 수준에서 OS의 논리적인 자원을 사용하여 애플리케이션을 구동하는 수준으로 추상화 수준이 높아진다.

    * 느슨하게 커플되고, 분산되고, 유연하며, 자유로운 마이크로서비스: 애플리케이션은 단일 목적의 머신에서 모놀리식 스택으로 구동되지 않고 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포되고 관리될 수 있다.

    * 자원 격리: 애플리케이션 성능을 예측할 수 있다.

    * 자원 사용량: 고효율 고집

      

### 쿠버네티스의 필요성

* 운영 환경에서의 컨테이너 관리
* 가동 중지 시간이 없는지 확인
* 다운되면 다른 컨테이너 다시 시작
* 분산 시스템을 탄력적으로 실행
* 애플리케이션의 확장과 장애 조치
* 배포 패턴 제공 (카나리아 배포)

### 기능

1. **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있다.
2. **스토리지 오케스트레이션** 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
3. **자동화된 롤아웃과 롤백** 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다. 예를 들어 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
4. **자동화된 빈 패킹(bin packing)** 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공한다. 각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시한다. 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
5. **자동화된 복구(self-healing)** 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않는다.
6. **시크릿과 구성 관리** 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다. 컨테이너 이미지를 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이트 할 수 있다.

## 쿠버네티스 컴포넌트

> 쿠버네티스를 구성하면 클러스터를 얻는다.
>
> 클러스터는 쿠버네티스에서 관리하는 컨테이너화된 애플리케이션을 실행하는 노드라고 하는 기계의 집합
>
> 최소 1개의 워커노드, 최소 1개의 마스터 노드를 가짐
>
> 워커노드는 애플리케이션의 구성요소인 파드를 호스트, 마스터노드는 워커노드와 클러스터 내 파드를 관리
>
> (다수의 마스터 노드는 장애극복과 고가용성의 클러스터에서 사용)



### 구성요소

#### 마스터 컴포넌트

> 클러스터의 컨트롤 플레인을 제공
>
> 클러스터 전반적인 결정 수행, 클러스터 이벤트감지 및 반응
>
> 클러스터 내 어떠한 머신에서든지 동작 가능, 간결성을 위해 구성 스크립트는 보통 동일 머신 상에 모든 마스터 컴포넌트 구성, 사용자 컨테이너는 해당 머신 상에 동작시키지 않음